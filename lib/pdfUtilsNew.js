import jsPDF from "jspdf";
import 'svg2pdf.js';
import html2canvas from "html2canvas";
// Plotly is dynamically imported to avoid SSR issues

// ===== STYLING CONSTANTS =====
export const PDF_STYLES = {
    colors: {
        headerBg: [36, 46, 66],           // Dark blue
        headerText: [255, 255, 255],      // White
        primaryBlue: [59, 130, 246],      // Blue (for headers)
        textDark: [31, 41, 55],           // Dark gray (#1f2937)
        textLight: [107, 114, 128],       // Light gray
        accentGreen: [34, 197, 94],       // Green
        borderGray: [229, 231, 235],      // Light border (#e5e7eb)
        tableLabelBg: [243, 244, 246],    // gray-100 (#f3f4f6) - for label cells
        tableDataBg: [255, 255, 255],     // white - for data cells
        tableHeaderBg: [36, 46, 66],      // Use header dark blue for table headers
    },
    fonts: {
        headerTitle: 15,
        headerSubtitle: 10,
        sectionTitle: 14,
        subSectionTitle: 12,
        bodyText: 10,
        smallText: 8,
    },
    margins: {
        page: 15,        // Page margins
        header: 19,      // Space after header
        footer: 15,      // Space before footer
        section: 10,     // Space between sections
    },
    pageSize: {
        width: 210,      // A4 width in mm
        height: 297,     // A4 height in mm
    }
};

// ===== HEADER FUNCTION =====
export const addHeader = (pdf, projectName) => {
    const { colors, fonts, pageSize } = PDF_STYLES;

    // Header background - 10mm height
    pdf.setFillColor(...colors.headerBg);
    pdf.rect(0, 0, pageSize.width, 10, 'F');

    // Project name - aligned with description (x=10)
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(fonts.headerTitle);
    pdf.setFont("helvetica", "bold");
    pdf.text(projectName, 10, 7);

    // Date - aligned with right edge of project details table (tableX + tableWidth = 80 + 120 = 200)
    pdf.setFontSize(fonts.headerSubtitle);
    pdf.setFont("helvetica", "normal");
    const dateText = new Date().toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
    });
    const dateWidth = pdf.getTextWidth(dateText);
    const tableRightEdge = 200; // tableX (80) + tableWidth (120)
    pdf.text(dateText, tableRightEdge - dateWidth, 7);
};

// ===== HELPER: Rounded Rectangle =====
const addRoundedRect = (pdf, x, y, w, h, radius = 2, style = 'S') => {
    // Use jsPDF's roundedRect function for rounded corners
    pdf.roundedRect(x, y, w, h, radius, radius, style);
};

// ===== HELPER: Add table outer border with rounded corners =====
const addTableBorder = (pdf, x, y, width, height, radius = 2) => {
    const { colors } = PDF_STYLES;
    pdf.setDrawColor(...colors.borderGray);
    pdf.setLineWidth(0.5);
    pdf.roundedRect(x, y, width, height, radius, radius, 'S');
};

// ===== FOOTER FUNCTION =====
export const addFooter = (pdf, pageNumber, totalPages, footerText = "") => {
    const { colors, fonts, pageSize } = PDF_STYLES;
    const footerY = pageSize.height - 7;

    // Separator line
    pdf.setDrawColor(...colors.borderGray);
    pdf.setLineWidth(0.3);
    pdf.line(15, footerY - 3, pageSize.width - 15, footerY - 3);

    // Page number (centered)
    pdf.setTextColor(...colors.textLight);
    pdf.setFontSize(fonts.smallText);
    pdf.setFont("helvetica", "normal");
    const pageText = `Page ${pageNumber} of ${totalPages}`;
    const pageTextWidth = pdf.getTextWidth(pageText);
    pdf.text(pageText, (pageSize.width - pageTextWidth) / 2, footerY);

    // Optional footer text (left side)
    if (footerText) {
        pdf.setFontSize(fonts.smallText);
        pdf.text(footerText, 15, footerY);
    }

    // Company/Generated text (right side)
    const generatedText = "Generated by OneView";
    const generatedWidth = pdf.getTextWidth(generatedText);
    pdf.text(generatedText, pageSize.width - generatedWidth - 15, footerY);
};

// ===== HELPER: Add New Page with Header & Footer =====
export const addNewPage = (pdf, projectName, pageTitle, pageNumber, totalPages) => {
    pdf.addPage();
    addHeader(pdf, projectName, pageTitle, pageNumber);
    addFooter(pdf, pageNumber, totalPages);

    // Return the Y position where content can start
    return PDF_STYLES.margins.header;
};

// ===== HELPER: Add Dotted Line =====
const addDottedLine = (pdf, startX, y, width) => {
    pdf.setDrawColor(200, 200, 200); // Light gray color
    pdf.setLineWidth(0.3);
    
    // Draw dotted line (dash pattern)
    const dashLength = 2;
    const gapLength = 2;
    let currentX = startX;
    
    while (currentX < startX + width) {
        pdf.line(currentX, y, Math.min(currentX + dashLength, startX + width), y);
        currentX += dashLength + gapLength;
    }
    
    return y + 3; // Return Y position after line with spacing
};

// ===== SECTION TITLE HELPER =====
export const addSectionTitle = (pdf, title, y) => {
    const { colors, fonts } = PDF_STYLES;

    pdf.setFontSize(fonts.sectionTitle);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(...colors.headerBg); // Use header color instead of primaryBlue
    pdf.text(title, 10, y);

    return y + 5; // Return new Y position (reduced from 5 to 3)
};

// ===== PROJECT DESCRIPTION SECTION =====
export const addProjectDescription = (pdf, projectData, startY) => {
    const { colors, fonts, pageSize } = PDF_STYLES;

    // Add section title
    let y = addSectionTitle(pdf, "Description", startY);

    // Get description text
    const description = projectData?.description || "No description available";

    // Set up text styling
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "normal");
    pdf.setTextColor(...colors.textDark);

    // Split text into lines that fit the page width
    const maxWidth = 60;
    const lines = pdf.splitTextToSize(description, maxWidth);

    // Add each line with justified alignment
    const lineHeight = 4;
    lines.forEach((line, index) => {
        // Use justify align with maxWidth parameter
        pdf.text(line, 10, y + (index * lineHeight), { maxWidth: maxWidth, align: 'justify' });
    });

    // Return new Y position (with some spacing after)
    return y + (lines.length * lineHeight) + 10;
};

// ===== MILESTONE TIMELINE SECTION =====
export const addMilestoneTimeline = (pdf, projectData, startY) => {
    const { colors, fonts, pageSize } = PDF_STYLES;
    const milestones = projectData?.milestones || {};

    // Add section title
    let y = addSectionTitle(pdf, "Milestones", startY);

    // Helper to format date as YYYY-MM-DD
    const formatDate = (date) => {
        if (!date) return null;
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    };

    // Helper to get earliest date from array
    const getEarliestDate = (dates) => {
        const validDates = dates.filter(d => d != null).map(d => new Date(d));
        if (validDates.length === 0) return null;
        return new Date(Math.min(...validDates));
    };

    // Build timeline events array
    const timelineEvents = [];

    // Offtake milestones - earliest dates
    const offtakeExecutedDates = milestones.offtake?.map(o => o.offtake_executed_date).filter(Boolean) || [];
    const offtakeCodDates = milestones.offtake?.map(o => o.offtake_cod_date).filter(Boolean) || [];

    const earliestOfftakeExecuted = getEarliestDate(offtakeExecutedDates);
    const earliestOfftakeCod = getEarliestDate(offtakeCodDates);

    if (earliestOfftakeExecuted) {
        timelineEvents.push({
            date: formatDate(earliestOfftakeExecuted),
            label: 'Offtake Execution'
        });
    }
    if (earliestOfftakeCod) {
        timelineEvents.push({
            date: formatDate(earliestOfftakeCod),
            label: 'Offtake COD'
        });
    }

    // Finance milestones - earliest dates
    const financeClosingDates = milestones.finance?.map(f => f.financial_closing_date).filter(Boolean) || [];
    const teFundingDates = milestones.finance?.map(f => f.te_initial_funding_date).filter(Boolean) || [];
    const termConversionDates = milestones.finance?.map(f => f.term_conversion_date).filter(Boolean) || [];
    const recaptureDates = milestones.finance?.map(f => f.recapture_date).filter(Boolean) || [];

    const earliestFinanceClosing = getEarliestDate(financeClosingDates);
    const earliestTeFunding = getEarliestDate(teFundingDates);
    const earliestTermConversion = getEarliestDate(termConversionDates);
    const earliestRecapture = getEarliestDate(recaptureDates);

    if (earliestFinanceClosing) {
        timelineEvents.push({
            date: formatDate(earliestFinanceClosing),
            label: 'Financial Closing'
        });
    }
    if (earliestTeFunding) {
        timelineEvents.push({
            date: formatDate(earliestTeFunding),
            label: 'TE Initial Funding'
        });
    }
    if (earliestTermConversion) {
        timelineEvents.push({
            date: formatDate(earliestTermConversion),
            label: 'Term Conversion'
        });
    }
    if (earliestRecapture) {
        timelineEvents.push({
            date: formatDate(earliestRecapture),
            label: 'Recapture Date'
        });
    }

    // Interconnect milestones - earliest dates
    const interconnectExecutedDates = milestones.interconnect?.map(i => i.interconnection_executed_date).filter(Boolean) || [];
    const interconnectCodDates = milestones.interconnect?.map(i => i.interconnect_cod_date).filter(Boolean) || [];

    const earliestInterconnectExecuted = getEarliestDate(interconnectExecutedDates);
    const earliestInterconnectCod = getEarliestDate(interconnectCodDates);

    if (earliestInterconnectExecuted) {
        timelineEvents.push({
            date: formatDate(earliestInterconnectExecuted),
            label: 'Interconnect Execution'
        });
    }
    if (earliestInterconnectCod) {
        timelineEvents.push({
            date: formatDate(earliestInterconnectCod),
            label: 'Interconnect COD'
        });
    }

    // EPC milestones - earliest dates
    const mechanicalCompletionDates = milestones.epc?.map(e => e.mechanical_completion_date).filter(Boolean) || [];
    const substantialCompletionDates = milestones.epc?.map(e => e.substantial_completion_date).filter(Boolean) || [];

    const earliestMechanicalCompletion = getEarliestDate(mechanicalCompletionDates);
    const earliestSubstantialCompletion = getEarliestDate(substantialCompletionDates);

    if (earliestMechanicalCompletion) {
        timelineEvents.push({
            date: formatDate(earliestMechanicalCompletion),
            label: 'Mechanical Completion'
        });
    }
    if (earliestSubstantialCompletion) {
        timelineEvents.push({
            date: formatDate(earliestSubstantialCompletion),
            label: 'Substantial Completion'
        });
    }

    // Filter out null dates and only show past milestones
    const validEvents = timelineEvents.filter(event => {
        if (event.date === null) return false;
        const eventDate = new Date(event.date);
        const currentDate = new Date();
        return eventDate <= currentDate;
    });

    // Sort by date
    validEvents.sort((a, b) => new Date(a.date) - new Date(b.date));

    // If no milestones
    if (validEvents.length === 0) {
        pdf.setFontSize(fonts.bodyText);
        pdf.setFont("helvetica", "italic");
        pdf.setTextColor(...colors.textLight);
        pdf.text("No milestones available", 15, y);
        return y + 10;
    }

    // Draw vertical timeline with dots
    const lineHeight = 12;
    const leftMargin = 10;
    const dotX = leftMargin;
    const textX = dotX + 8;

    validEvents.forEach((event, index) => {
        const currentY = y + (index * lineHeight);

        // Draw vertical line (except for last item)
        if (index < validEvents.length - 1) {
            pdf.setDrawColor(...colors.primaryBlue);
            pdf.setLineWidth(1);
            pdf.line(dotX, currentY, dotX, currentY + lineHeight);
        }

        // Draw dot
        pdf.setFillColor(...colors.primaryBlue);
        pdf.circle(dotX, currentY, 2, 'F');

        // Event label (bold) - reduced font size
        pdf.setFont("helvetica", "bold");
        pdf.setFontSize(fonts.smallText);
        pdf.setTextColor(...colors.textDark);
        pdf.text(event.label, textX, currentY);

        // Event date (below label, lighter)
        pdf.setFont("helvetica", "normal");
        pdf.setFontSize(fonts.smallText - 1);
        pdf.setTextColor(...colors.textLight);
        pdf.text(event.date, textX, currentY + 3.5);
    });

    return y + (validEvents.length * lineHeight) + 3;
};

// ===== UPCOMING EVENTS TABLE =====
export const addUpcomingEventsTable = (pdf, projectData, startY) => {
    const { colors, fonts } = PDF_STYLES;
    const milestones = projectData?.milestones || {};
    const upcomingEvents = [];
    const currentDate = new Date();

    // Helper to format date as YYYY-MM-DD
    const formatDate = (date) => {
        if (!date) return null;
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return {
            dateObj: d,
            formatted: `${year}-${month}-${day}`
        };
    };

    // Offtake - first record only
    const offtakeFirst = milestones.offtake?.[0];
    if (offtakeFirst) {
        if (offtakeFirst.offtake_executed_date) {
            const formattedDate = formatDate(offtakeFirst.offtake_executed_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Offtake Executed',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
        if (offtakeFirst.offtake_cod_date) {
            const formattedDate = formatDate(offtakeFirst.offtake_cod_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Offtake COD',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
    }

    // Finance - first record only
    const financeFirst = milestones.finance?.[0];
    if (financeFirst) {
        if (financeFirst.financial_closing_date) {
            const formattedDate = formatDate(financeFirst.financial_closing_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Financial Closing',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
        if (financeFirst.te_initial_funding_date) {
            const formattedDate = formatDate(financeFirst.te_initial_funding_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'TE Initial Funding',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
        if (financeFirst.term_conversion_date) {
            const formattedDate = formatDate(financeFirst.term_conversion_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Term Conversion',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
        if (financeFirst.recapture_date) {
            const formattedDate = formatDate(financeFirst.recapture_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Recapture Date',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
    }

    // Interconnect - first record only
    const interconnectFirst = milestones.interconnect?.[0];
    if (interconnectFirst) {
        if (interconnectFirst.interconnection_executed_date) {
            const formattedDate = formatDate(interconnectFirst.interconnection_executed_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Interconnection Executed',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
        if (interconnectFirst.interconnect_cod_date) {
            const formattedDate = formatDate(interconnectFirst.interconnect_cod_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'IA COD',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
    }

    // EPC - first record only
    const epcFirst = milestones.epc?.[0];
    if (epcFirst) {
        if (epcFirst.mechanical_completion_date) {
            const formattedDate = formatDate(epcFirst.mechanical_completion_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Mechanical Completion',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
        if (epcFirst.substantial_completion_date) {
            const formattedDate = formatDate(epcFirst.substantial_completion_date);
            if (formattedDate && formattedDate.dateObj > currentDate) {
                upcomingEvents.push({
                    label: 'Substantial Completion',
                    date: formattedDate.formatted,
                    dateObj: formattedDate.dateObj
                });
            }
        }
    }

    // Sort by date (earliest first)
    upcomingEvents.sort((a, b) => a.dateObj - b.dateObj);

    // Add section title
    let y = addSectionTitle(pdf, "Upcoming Events", startY);

    // If no upcoming events
    if (upcomingEvents.length === 0) {
        pdf.setFontSize(fonts.bodyText);
        pdf.setFont("helvetica", "italic");
        pdf.setTextColor(...colors.textLight);
        pdf.text("No upcoming events", 15, y);
        return y + 10;
    }

    // Draw events as cards/boxes
    const leftMargin = 10;
    const boxWidth = 50;
    const boxPadding = 3;
    const boxSpacing = 3;

    upcomingEvents.forEach((event, index) => {
        const boxHeight = 10;

        // Draw box background (light gray)
        pdf.setFillColor(245, 245, 245);
        pdf.rect(leftMargin, y, boxWidth, boxHeight, 'F');

        // Draw box border
        pdf.setDrawColor(...colors.borderGray);
        pdf.setLineWidth(0.1);
        pdf.rect(leftMargin, y, boxWidth, boxHeight, 'S');

        // Event label (bold)
        pdf.setFont("helvetica", "bold");
        pdf.setFontSize(fonts.bodyText);
        pdf.setTextColor(...colors.textDark);
        pdf.text(event.label, leftMargin + boxPadding, y + 4);

        // Event date (below label)
        pdf.setFont("helvetica", "normal");
        pdf.setFontSize(fonts.smallText);
        pdf.setTextColor(...colors.textDark);
        pdf.text(event.date, leftMargin + boxPadding, y + 7.5);

        y += boxHeight + boxSpacing;
    });

    return y + 5;
};

// ===== PROJECT LOCATION TABLE =====
export const addProjectLocationTable = (pdf, projectData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;
    const overview = projectData?.overview || {};

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("Project Location & Site Details", startX + 2, startY + 4.5);

    let y = startY + 7;
    const baseRowHeight = 6;
    const labelWidth = width * 0.55;
    const valueWidth = width * 0.45;

    const fields = [
        { label: 'Address', value: overview.address },
        { label: 'Facility Type', value: overview.facility_type },
        { label: 'Project Stage', value: overview.project_stage },
        { label: 'DC Capacity (MW)', value: overview.dc_capacity },
        { label: 'POI AC Capacity (MW)', value: overview.poi_ac_capacity },
        { label: 'DC/AC Ratio', value: overview.dc_ac_ratio }
    ];

    pdf.setFontSize(7);
    pdf.setFont("helvetica", "normal");

    fields.forEach((field, index) => {
        // Set border color to gray FIRST
        pdf.setDrawColor(...colors.borderGray);
        pdf.setLineWidth(0.1);

        const valueText = field.value || '-';

        // Calculate max width for text wrapping (subtract padding)
        const maxTextWidth = valueWidth - 3;

        // Split text into lines that fit
        const valueLines = pdf.splitTextToSize(String(valueText), maxTextWidth);

        // Calculate row height based on number of lines
        const rowHeight = Math.max(baseRowHeight, valueLines.length * 4 + 2);

        // Label cell (gray-100 background)
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, labelWidth, rowHeight, 'FD');

        // Value cell (white background)
        pdf.setFillColor(...colors.tableDataBg);
        pdf.rect(startX + labelWidth, y, valueWidth, rowHeight, 'FD');

        // Label text (bold, dark)
        pdf.setTextColor(...colors.textDark);
        pdf.setFont("helvetica", "normal");
        pdf.text(field.label, startX + 1.5, y + 4);

        // Value text (wrapped, multiple lines if needed)
        pdf.setFont("helvetica", "normal");
        valueLines.forEach((line, lineIndex) => {
            pdf.text(line, startX + labelWidth + 1.5, y + 4 + (lineIndex * 4));
        });

        y += rowHeight;
    });

    return y;
};

// ===== ASSOCIATED PARTIES TABLE =====
export const addAssociatedPartiesTable = (pdf, projectData, financeData, startX, startY, width) => {
    const { colors } = PDF_STYLES;

    // Helper function to get unique values
    const getUniqueValues = (data, field) => {
        if (!data || !Array.isArray(data)) return [];
        return [...new Set(data.map(item => item[field]).filter(Boolean))];
    };

    // Extract parties from each category
    const offtakeParties = getUniqueValues(projectData?.offtake?.contract_details, "offtake_counterparty");
    const interconnectionParties = getUniqueValues(projectData?.interconnection, "interconnection_counterparty_to");
    const constructionParties = getUniqueValues(projectData?.construction, "contractor_name");
    const omParties = getUniqueValues(projectData?.assetManagement?.om, "o_and_m_contractor");
    const moduleManufacturers = getUniqueValues(projectData?.equipments?.modules, "manufacturer");
    const inverterManufacturers = getUniqueValues(projectData?.equipments?.inverters, "manufacturer");
    const rackingManufacturers = getUniqueValues(projectData?.equipments?.racking, "manufacturer");
    const transformerManufacturers = getUniqueValues(projectData?.equipments?.transformers, "manufacturer");

    // Lender parties
    const lenderParties = financeData?.lenderCommitments?.['Term Loan']
        ? Object.keys(financeData.lenderCommitments['Term Loan']).filter(key => key !== 'Unknown')
        : [];

    // Tax Equity parties - exact same logic as dashboard
    const taxEquityParties = (() => {
        const parties = new Set(); // Use Set to avoid duplicates
        if (financeData?.taxEquity) {
            Object.entries(financeData.taxEquity).forEach(([typeName, parameters]) => {
                // For Traditional Flip
                const classAInvestor = parameters['Class A Investor Name (In a case of Traditional Flip)'];
                if (classAInvestor && classAInvestor !== '-') {
                    parties.add(classAInvestor);
                }
                // For Transfer
                const taxCreditBuyer = parameters['Tax Credit Buyer (In a case of Transfer)'];
                if (taxCreditBuyer && taxCreditBuyer !== '-') {
                    parties.add(taxCreditBuyer);
                }
            });
        }
        const result = Array.from(parties); // Convert Set back to array
        console.log('PDF Tax Equity Parties:', result);
        return result;
    })();

    // Calculate max parties
    const maxParties = Math.max(
        offtakeParties.length,
        interconnectionParties.length,
        constructionParties.length,
        omParties.length,
        moduleManufacturers.length,
        inverterManufacturers.length,
        rackingManufacturers.length,
        transformerManufacturers.length,
        lenderParties.length,
        taxEquityParties.length,
        1
    );

    console.log('PDF Associated Parties Lengths:', {
        offtake: offtakeParties.length,
        interconnection: interconnectionParties.length,
        construction: constructionParties.length,
        om: omParties.length,
        modules: moduleManufacturers.length,
        inverters: inverterManufacturers.length,
        racking: rackingManufacturers.length,
        transformers: transformerManufacturers.length,
        lender: lenderParties.length,
        taxEquity: taxEquityParties.length,
        maxParties: maxParties
    });

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("Associated Parties", startX + 2, startY + 4.5);

    let y = startY + 7;
    const baseRowHeight = 6;
    const fieldWidth = width * 0.20; // Reduced from 0.25 to 0.20
    const partyWidth = (width - fieldWidth) / maxParties;

    // Column headers
    pdf.setFillColor(...colors.tableLabelBg);
    pdf.rect(startX, y, fieldWidth, baseRowHeight, 'FD');
    pdf.setTextColor(...colors.textDark);
    pdf.setFontSize(7);
    pdf.setFont("helvetica", "bold");
    pdf.text("Field", startX + 1, y + 4);

    for (let i = 0; i < maxParties; i++) {
        const cellX = startX + fieldWidth + (i * partyWidth);
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(cellX, y, partyWidth, baseRowHeight, 'FD');
        pdf.text(`Counterparty ${i + 1}`, cellX + 1, y + 4);
    }

    pdf.setDrawColor(...colors.borderGray);
    pdf.rect(startX, y, width, baseRowHeight, 'S');
    y += baseRowHeight;

    // Helper to add a section header
    const addSectionHeader = (title) => {
        pdf.setFillColor(...colors.tableLabelBg);  // Same color as ThirdParty Ownership, Sizing DSCR
        pdf.rect(startX, y, width, baseRowHeight, 'FD');
        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, baseRowHeight, 'S');
        pdf.setTextColor(...colors.textDark);  // Dark text instead of white
        pdf.setFont("helvetica", "bold");
        pdf.text(title, startX + 2, y + 4);
        y += baseRowHeight;
    };

    // Helper to add a data row with text wrapping
    const addDataRow = (label, parties) => {
        pdf.setFontSize(7);
        pdf.setFont("helvetica", "normal");

        // Calculate max text width for wrapping (subtract padding)
        const maxPartyTextWidth = partyWidth - 2;

        // Wrap text for all party values
        const wrappedValues = [];
        let maxLines = 1;

        for (let i = 0; i < maxParties; i++) {
            const value = parties[i] || '-';
            const valueLines = pdf.splitTextToSize(String(value), maxPartyTextWidth);
            wrappedValues.push(valueLines);
            maxLines = Math.max(maxLines, valueLines.length);
        }

        // Calculate row height based on max lines
        const rowHeight = Math.max(baseRowHeight, maxLines * 4 + 2);

        // Field cell
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, fieldWidth, rowHeight, 'FD');
        pdf.setTextColor(...colors.textDark);
        pdf.text(label, startX + 1, y + 4);

        // Party cells with wrapped text
        for (let i = 0; i < maxParties; i++) {
            const cellX = startX + fieldWidth + (i * partyWidth);
            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(cellX, y, partyWidth, rowHeight, 'FD');

            // Render wrapped text
            wrappedValues[i].forEach((line, lineIndex) => {
                pdf.text(line, cellX + 1, y + 4 + (lineIndex * 4));
            });
        }

        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, rowHeight, 'S');
        y += rowHeight;
    };

    // COMMERCIAL SECTION
    addSectionHeader("Commercial");
    addDataRow("PPA", offtakeParties);
    addDataRow("Interconnection", interconnectionParties);
    addDataRow("EPC", constructionParties);
    addDataRow("O&M", omParties);

    // EQUIPMENTS SECTION
    addSectionHeader("Equipments");
    addDataRow("Modules", moduleManufacturers);
    addDataRow("Inverters", inverterManufacturers);
    addDataRow("Racking", rackingManufacturers);
    addDataRow("GSU Transformer", transformerManufacturers);

    // FINANCE SECTION
    addSectionHeader("Finance");
    addDataRow("Lender", lenderParties);
    addDataRow("Tax Equity", taxEquityParties);

    return y;
};

// ===== HELPER: Add SVG Chart to PDF =====
/**
 * Adds an SVG chart directly to the PDF (vector quality)
 * @param {jsPDF} pdf - PDF instance
 * @param {SVGElement} svgElement - The SVG element to embed
 * @param {string} title - Chart title (optional)
 * @param {number} startX - X position
 * @param {number} startY - Y position
 * @param {number} maxWidth - Maximum chart width
 * @param {number} maxHeight - Maximum chart height
 * @returns {number} - Y position after the chart
 */
export const addSvgChart = async (pdf, svgElement, title, startX, startY, maxWidth, maxHeight) => {
    const { colors } = PDF_STYLES;

    if (!svgElement) {
        // If no SVG, show placeholder
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, maxWidth, maxHeight, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('Chart not available', startX + maxWidth / 2, startY + maxHeight / 2, { align: 'center' });
        return startY + maxHeight + 5;
    }

    // Add title if provided
    if (title) {
        pdf.setFillColor(...colors.tableHeaderBg);
        addRoundedRect(pdf, startX, startY, maxWidth, 7, 2, 'F');
        pdf.setTextColor(...colors.headerText);
        pdf.setFontSize(8);
        pdf.setFont("helvetica", "bold");
        pdf.text(title, startX + 2, startY + 4.5);
        startY += 7;
    }

    // Clone the SVG to avoid modifying the original
    const svgClone = svgElement.cloneNode(true);

    // Get original dimensions
    const viewBox = svgClone.getAttribute('viewBox');
    let svgWidth = parseFloat(svgClone.getAttribute('width')) || maxWidth;
    let svgHeight = parseFloat(svgClone.getAttribute('height')) || maxHeight;

    // If viewBox exists, use it for aspect ratio
    if (viewBox) {
        const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
        svgWidth = vbWidth;
        svgHeight = vbHeight;
    }

    // Calculate dimensions maintaining aspect ratio
    const aspectRatio = svgWidth / svgHeight;
    let finalWidth = maxWidth;
    let finalHeight = maxWidth / aspectRatio;

    // If calculated height exceeds max height, scale by height instead
    if (finalHeight > maxHeight) {
        finalHeight = maxHeight;
        finalWidth = maxHeight * aspectRatio;
    }

    // Center the chart within the available space
    const offsetX = (maxWidth - finalWidth) / 2;

    try {
        // Add the SVG to PDF using svg2pdf.js
        await pdf.svg(svgClone, {
            x: startX + offsetX,
            y: startY,
            width: finalWidth,
            height: finalHeight
        });
    } catch (error) {
        console.error('Error embedding SVG:', error);
        // Show error placeholder
        pdf.setFillColor(255, 240, 240);
        pdf.rect(startX, startY, maxWidth, maxHeight, 'F');
        pdf.setTextColor(200, 50, 50);
        pdf.setFontSize(8);
        pdf.text('Error loading chart', startX + maxWidth / 2, startY + maxHeight / 2, { align: 'center' });
    }

    return startY + finalHeight + 5;
};

// ===== DSCR TABLE =====
export const addDscrTable = (pdf, financeData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;

    console.log('üìä addDscrTable called');
    console.log('   financeData:', financeData);
    console.log('   financeData.dscr:', financeData?.dscr);
    console.log('   dscr length:', financeData?.dscr?.length);

    const tableStartY = startY;

    // Table header (blue background, white text) - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("DSCR", startX + 2, startY + 4.5);

    let y = startY + 7;
    const rowHeight = 6;
    const col1Width = width * 0.4;  // Field
    const col2Width = width * 0.3;  // Value
    const col3Width = width * 0.3;  // As of Date

    // Column headers (gray background)
    pdf.setFillColor(...colors.tableLabelBg);
    pdf.rect(startX, y, col1Width, rowHeight, 'FD');
    pdf.rect(startX + col1Width, y, col2Width, rowHeight, 'FD');
    pdf.rect(startX + col1Width + col2Width, y, col3Width, rowHeight, 'FD');

    pdf.setTextColor(...colors.textDark);
    pdf.setFontSize(7);
    pdf.setFont("helvetica", "bold");
    pdf.text("Field", startX + 1, y + 4);
    pdf.text("Value", startX + col1Width + 1, y + 4);
    pdf.text("As of Date", startX + col1Width + col2Width + 1, y + 4);

    pdf.setDrawColor(...colors.borderGray);
    pdf.rect(startX, y, width, rowHeight, 'S');
    y += rowHeight;

    // DSCR rows
    const dscrData = financeData?.dscr || [];

    console.log('üìà DSCR data array:', dscrData);
    console.log('   Is array?', Array.isArray(dscrData));
    console.log('   Length:', dscrData.length);

    if (dscrData.length > 0) {
        console.log('‚úÖ DSCR data found, rendering rows...');
        pdf.setFont("helvetica", "normal");

        dscrData.forEach((item, index) => {
            console.log(`   Row ${index}:`, item);
            console.log(`     parameter:`, item.parameter);
            console.log(`     value:`, item.value);
            console.log(`     asOfDate:`, item.asOfDate);

            // Field cell (gray background)
            pdf.setFillColor(...colors.tableLabelBg);
            pdf.rect(startX, y, col1Width, rowHeight, 'FD');

            // Value cell (white background)
            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(startX + col1Width, y, col2Width, rowHeight, 'FD');

            // Date cell (white background)
            pdf.rect(startX + col1Width + col2Width, y, col3Width, rowHeight, 'FD');

            // Border
            pdf.setDrawColor(...colors.borderGray);
            pdf.rect(startX, y, width, rowHeight, 'S');

            // Text
            pdf.setTextColor(...colors.textDark);
            pdf.setFontSize(7);

            // Handle parameter as object or string
            const parameterName = item.parameter?.parameter_name || item.parameter || '-';
            console.log(`     Extracted parameter name:`, parameterName);

            const fieldText = String(parameterName);

            pdf.text(fieldText, startX + 1, y + 4);

            const valueText = String(item.value || '-');
            pdf.text(valueText, startX + col1Width + 1, y + 4);

            // Format date as YYYY-MM-DD
            let dateText = '-';
            if (item.asOfDate) {
                const d = new Date(item.asOfDate);
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                dateText = `${year}-${month}-${day}`;
            }
            pdf.text(dateText, startX + col1Width + col2Width + 1, y + 4);

            y += rowHeight;
        });

        console.log('‚úÖ All DSCR rows rendered');
    } else {
        console.warn('‚ö†Ô∏è No DSCR data available');
        pdf.setFillColor(...colors.tableDataBg);
        pdf.rect(startX, y, width, rowHeight, 'FD');
        pdf.setTextColor(...colors.textLight);
        pdf.setFont("helvetica", "italic");
        pdf.text("No DSCR data available", startX + width / 2 - 20, y + 4);
        y += rowHeight;
    }

    return y;
};
// ===== O&M DETAILS TABLE (FULL WIDTH, MULTIPLE COLUMNS) =====
export const addOMDetailsTable = (pdf, projectData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;
    const omData = projectData?.assetManagement?.om || [];

    console.log('üîß Adding O&M Details table');
    console.log('   O&M data:', omData);

    if (omData.length === 0) {
        return startY; // Skip if no data
    }

    const numOMContracts = Math.min(omData.length, 3); // Limit to 3 contracts for space

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("O&M Details", startX + 2, startY + 4.5);

    let y = startY + 7;
    const labelWidth = width * 0.35;
    const omWidth = (width - labelWidth) / numOMContracts;

    // Column headers - removed "Field" row
    // No header row needed

    // Define rows
    const rows = [
        { label: 'O&M Contractor', field: 'o_and_m_contractor' },
        { label: 'Service Fee ($/kW)', field: 'service_fee', format: 'number' },
        { label: 'Term (Years)', field: 'term', format: 'number' },
        { label: 'Escalator (%)', field: 'escalator', format: 'number' },
        { label: 'Availability Guarantee (%)', field: 'availability_guarantee_percent', format: 'number' }
    ];

    pdf.setFont("helvetica", "normal");
    rows.forEach((row) => {
        const maxLabelWidth = labelWidth - 2;
        const labelLines = pdf.splitTextToSize(row.label, maxLabelWidth);

        // Calculate wrapped lines for all values to determine row height
        const maxTextWidth = omWidth - 2;
        let maxValueLines = 0;
        const wrappedValues = [];

        for (let i = 0; i < numOMContracts; i++) {
            const om = omData[i];
            let value = om?.[row.field];

            // Format value
            if (value === null || value === undefined || value === '') {
                value = '-';
            } else if (row.format === 'number') {
                value = Number(value).toLocaleString('en-US');
            } else {
                value = String(value);
            }

            const textLines = pdf.splitTextToSize(String(value), maxTextWidth);
            wrappedValues.push(textLines);
            maxValueLines = Math.max(maxValueLines, textLines.length);
        }

        // Row height based on max lines between label and values
        const maxLines = Math.max(labelLines.length, maxValueLines);
        const labelRowHeight = Math.max(6, maxLines * 4 + 2);

        // Label cell (gray background)
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, labelWidth, labelRowHeight, 'FD');
        pdf.setTextColor(...colors.textDark);

        // Render wrapped label text
        labelLines.forEach((line, lineIndex) => {
            pdf.text(line, startX + 1, y + 4 + (lineIndex * 4));
        });

        // Value cells for each O&M contract
        for (let i = 0; i < numOMContracts; i++) {
            const cellX = startX + labelWidth + (i * omWidth);

            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(cellX, y, omWidth, labelRowHeight, 'FD');

            // Render wrapped value text
            wrappedValues[i].forEach((line, lineIndex) => {
                pdf.text(line, cellX + 1, y + 4 + (lineIndex * 4));
            });
        }

        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, labelRowHeight, 'S');
        y += labelRowHeight;
    });

    return y;
};

// ===== OFFTAKE TABLE (FULL WIDTH, MULTIPLE COLUMNS) =====
export const addOfftakeTable = (pdf, projectData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;
    const offtakeData = projectData?.offtake?.contract_details || [];

    console.log('‚ö° Adding Offtake table');
    console.log('   Offtake data:', offtakeData);

    if (offtakeData.length === 0) {
        return startY; // Skip if no data
    }

    const numOfftakes = Math.min(offtakeData.length, 3); // Limit to 3 offtakes for space

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("Offtake Details", startX + 2, startY + 4.5);

    let y = startY + 7;
    const labelWidth = width * 0.35;
    const offtakeWidth = (width - labelWidth) / numOfftakes;

    // Column headers
    const headerHeight = 6;
    pdf.setFillColor(...colors.tableLabelBg);
    pdf.rect(startX, y, labelWidth, headerHeight, 'FD');
    pdf.setTextColor(...colors.textDark);
    pdf.setFontSize(7);
    pdf.setFont("helvetica", "bold");
    pdf.text("Field", startX + 1, y + 4);

    for (let i = 0; i < numOfftakes; i++) {
        const cellX = startX + labelWidth + (i * offtakeWidth);
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(cellX, y, offtakeWidth, headerHeight, 'FD');
        pdf.text(`Offtake ${i + 1}`, cellX + 1, y + 4);
    }

    pdf.setDrawColor(...colors.borderGray);
    pdf.rect(startX, y, width, headerHeight, 'S');
    y += headerHeight;

    // Define rows
    const rows = [
        { label: 'Offtake Counterparty', field: 'offtake_counterparty' },
        { label: 'Contracted Capacity (MW)', field: 'contracted_capacity', format: 'number' },
        { label: 'Contracted Price ($/MWh)', field: 'contract_price', format: 'number', source: 'prices' },
        { label: 'Energy Tenure Duration (Years)', field: 'energy_term_duration_years', format: 'years' },
        { label: 'Energy Delivery Term End Date', field: 'energy_delivery_term_end_date', format: 'date' },
        { label: 'Fixed or Escalating Price', field: 'fixed_or_escalating_price', source: 'prices' }
    ];

    pdf.setFont("helvetica", "normal");
    rows.forEach((row) => {
        const maxLabelWidth = labelWidth - 2;
        const labelLines = pdf.splitTextToSize(row.label, maxLabelWidth);

        // Calculate wrapped lines for all values to determine row height
        const maxTextWidth = offtakeWidth - 2;
        let maxValueLines = 0;
        const wrappedValues = [];

        for (let i = 0; i < numOfftakes; i++) {
            const offtake = offtakeData[i];
            let value;

            // Get value from appropriate source
            if (row.source === 'prices') {
                const priceData = projectData?.offtake?.prices_damage?.find(
                    price => price.offtake_counterparty === offtake.offtake_counterparty
                );
                value = priceData?.[row.field];
            } else {
                value = offtake[row.field];
            }

            // Format value
            if (!value) {
                value = '-';
            } else if (row.format === 'number') {
                value = Number(value).toLocaleString('en-US');
            } else if (row.format === 'years') {
                value = `${value} `;
            } else if (row.format === 'date') {
                // Format date as YYYY-MM-DD
                const d = new Date(value);
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                value = `${year}-${month}-${day}`;
            }

            const textLines = pdf.splitTextToSize(String(value), maxTextWidth);
            wrappedValues.push(textLines);
            maxValueLines = Math.max(maxValueLines, textLines.length);
        }

        // Row height based on max lines between label and values
        const maxLines = Math.max(labelLines.length, maxValueLines);
        const labelRowHeight = Math.max(6, maxLines * 4 + 2);

        // Label cell (gray background)
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, labelWidth, labelRowHeight, 'FD');
        pdf.setTextColor(...colors.textDark);

        // Render wrapped label text
        labelLines.forEach((line, lineIndex) => {
            pdf.text(line, startX + 1, y + 4 + (lineIndex * 4));
        });

        // Value cells for each offtake
        for (let i = 0; i < numOfftakes; i++) {
            const cellX = startX + labelWidth + (i * offtakeWidth);

            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(cellX, y, offtakeWidth, labelRowHeight, 'FD');

            // Render wrapped value text
            wrappedValues[i].forEach((line, lineIndex) => {
                pdf.text(line, cellX + 1, y + 4 + (lineIndex * 4));
            });
        }

        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, labelRowHeight, 'S');
        y += labelRowHeight;
    });

    return y;
};

// ===== DEBT VS SWAPS TABLE =====
export const addDebtVsSwapsTable = (pdf, financeData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;
    const debtVsSwaps = financeData?.debtVsSwaps || {};

    console.log('üí∞ Adding Debt vs Swaps table');
    console.log('   financeData received:', financeData);
    console.log('   debtVsSwaps data:', debtVsSwaps);
    console.log('   debtVsSwaps keys:', Object.keys(debtVsSwaps));
    console.log('   Number of entries:', Object.keys(debtVsSwaps).length);

    if (Object.keys(debtVsSwaps).length === 0) {
        console.warn('‚ö†Ô∏è No Debt vs Swaps data found, skipping table');
        return startY; // Skip if no data
    }

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("Debt vs Swaps", startX + 2, startY + 4.5);

    let y = startY + 7;
    const baseRowHeight = 6;
    const labelWidth = width * 0.6;
    const valueWidth = width * 0.4;

    pdf.setFontSize(7);
    pdf.setFont("helvetica", "normal");

    Object.entries(debtVsSwaps).forEach(([paramName, value]) => {
        pdf.setDrawColor(...colors.borderGray);
        pdf.setLineWidth(0.1);

        const valueText = value || '-';

        // Format value (add commas for numbers)
        let formattedValue = valueText;
        if (!isNaN(Number(valueText))) {
            formattedValue = Number(valueText).toLocaleString('en-US');
        }

        // Text wrapping for both label and value
        const maxLabelWidth = labelWidth - 3;
        const maxValueWidth = valueWidth - 3;

        const labelLines = pdf.splitTextToSize(String(paramName), maxLabelWidth);
        const valueLines = pdf.splitTextToSize(String(formattedValue), maxValueWidth);

        // Row height based on whichever has more lines
        const maxLines = Math.max(labelLines.length, valueLines.length);
        const rowHeight = Math.max(baseRowHeight, maxLines * 4 + 2);

        // Label cell (gray background)
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, labelWidth, rowHeight, 'FD');

        // Value cell (white background)
        pdf.setFillColor(...colors.tableDataBg);
        pdf.rect(startX + labelWidth, y, valueWidth, rowHeight, 'FD');

        // Text
        pdf.setTextColor(...colors.textDark);

        // Wrapped label text
        labelLines.forEach((line, lineIndex) => {
            pdf.text(line, startX + 1.5, y + 4 + (lineIndex * 4));
        });

        // Wrapped value text
        valueLines.forEach((line, lineIndex) => {
            pdf.text(line, startX + labelWidth + 1.5, y + 4 + (lineIndex * 4));
        });

        y += rowHeight;
    });

    return y;
};

// ===== CORPORATE FINANCING TABLE =====
export const addCorporateFinancingTable = (pdf, financeData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;
    const assetCo = financeData?.assetCo || [];
    const corporateDebt = financeData?.corporateDebt || {};

    console.log('üè¢ Adding Corporate Financing table');
    console.log('   Asset Co data:', assetCo);
    console.log('   Corporate Debt data:', corporateDebt);

    if (assetCo.length === 0 && Object.keys(corporateDebt).length === 0) {
        console.warn('‚ö†Ô∏è No Corporate Financing data found, skipping table');
        return startY;
    }

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("Corporate Financing", startX + 2, startY + 4.5);

    let y = startY + 7;
    const baseRowHeight = 6;
    const labelWidth = width * 0.6;
    const valueWidth = width * 0.4;

    // ===== SECTION 1: Third Party Ownership =====
    if (assetCo.length > 0) {
        // Section header - split into two columns like dashboard
        const sectionHeaderHeight = 6;
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'FD');
        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'S');

        pdf.setTextColor(...colors.textDark);
        pdf.setFontSize(7);
        pdf.setFont("helvetica", "bold");
        // Left text: "ThirdParty Ownership"
        pdf.text("ThirdParty Ownership", startX + 2, y + 4);
        // Right text: "Commitment ($)"
        const rightText = "Commitment ($)";
        const rightTextWidth = pdf.getTextWidth(rightText);
        pdf.text(rightText, startX + width - rightTextWidth - 2, y + 4);
        y += sectionHeaderHeight;

        // Asset Co data rows
        pdf.setFont("helvetica", "normal");
        assetCo.forEach((asset) => {
            pdf.setDrawColor(...colors.borderGray);
            pdf.setLineWidth(0.1);

            // Format name - rename "Sale to Allianz" to "Allianz"
            const rawName = asset.name || '-';
            const nameText = rawName === 'Sale to Allianz' ? 'Allianz' : rawName;
            const valueText = asset.commitment ? Number(asset.commitment).toLocaleString('en-US') : '-';

            // Text wrapping
            const maxLabelWidth = labelWidth - 3;
            const maxValueWidth = valueWidth - 3;

            const labelLines = pdf.splitTextToSize(String(nameText), maxLabelWidth);
            const valueLines = pdf.splitTextToSize(String(valueText), maxValueWidth);

            const maxLines = Math.max(labelLines.length, valueLines.length);
            const rowHeight = Math.max(baseRowHeight, maxLines * 4 + 2);

            // Label cell
            pdf.setFillColor(...colors.tableLabelBg);
            pdf.rect(startX, y, labelWidth, rowHeight, 'FD');

            // Value cell
            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(startX + labelWidth, y, valueWidth, rowHeight, 'FD');

            pdf.setTextColor(...colors.textDark);

            // Render text
            labelLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + 1.5, y + 4 + (lineIndex * 4));
            });

            valueLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + labelWidth + 1.5, y + 4 + (lineIndex * 4));
            });

            y += rowHeight;
        });
    }

    // ===== SECTION 2: Corporate Debt =====
    if (Object.keys(corporateDebt).length > 0) {
        // Section header (merged across columns)
        const sectionHeaderHeight = 6;
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'FD');
        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'S');

        pdf.setTextColor(...colors.textDark);
        pdf.setFontSize(7);
        pdf.setFont("helvetica", "bold");
        const sectionTitle = "Corporate Debt";
        const titleWidth = pdf.getTextWidth(sectionTitle);
        pdf.text(sectionTitle, startX + (width - titleWidth) / 2, y + 4);
        y += sectionHeaderHeight;

        // Corporate Debt data rows
        pdf.setFont("helvetica", "normal");
        Object.entries(corporateDebt).forEach(([paramName, value]) => {
            pdf.setDrawColor(...colors.borderGray);
            pdf.setLineWidth(0.1);

            const valueText = value || '-';

            // Format value (add commas for numbers)
            let formattedValue = valueText;
            if (!isNaN(Number(valueText))) {
                formattedValue = Number(valueText).toLocaleString('en-US');
            }

            // Text wrapping
            const maxLabelWidth = labelWidth - 3;
            const maxValueWidth = valueWidth - 3;

            const labelLines = pdf.splitTextToSize(String(paramName), maxLabelWidth);
            const valueLines = pdf.splitTextToSize(String(formattedValue), maxValueWidth);

            const maxLines = Math.max(labelLines.length, valueLines.length);
            const rowHeight = Math.max(baseRowHeight, maxLines * 4 + 2);

            // Label cell
            pdf.setFillColor(...colors.tableLabelBg);
            pdf.rect(startX, y, labelWidth, rowHeight, 'FD');

            // Value cell
            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(startX + labelWidth, y, valueWidth, rowHeight, 'FD');

            pdf.setTextColor(...colors.textDark);

            // Render text
            labelLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + 1.5, y + 4 + (lineIndex * 4));
            });

            valueLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + labelWidth + 1.5, y + 4 + (lineIndex * 4));
            });

      y += rowHeight;
    });
    }
    
    return y;
  };
  
// ===== KEY FINANCING TERMS TABLE =====
export const addKeyFinancingTermsTable = (pdf, financeData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;
    const financingTerms = financeData?.financingTerms || {};

    console.log('üîë Adding Key Financing Terms table');
    console.log('   Financing terms sections:', financingTerms.sections);

    // Find "Sizing DSCR" and "Interest Rate" sections
    const sizingDscrSection = financingTerms.sections?.find(
        section => section.sectionName.toLowerCase().includes('sizing dscr')
    );
    const interestRateSection = financingTerms.sections?.find(
        section => section.sectionName.toLowerCase().includes('interest rate')
    );

    if (!sizingDscrSection && !interestRateSection) {
        console.warn('‚ö†Ô∏è No Key Financing Terms data found, skipping table');
        return startY;
    }

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("Key Financing Terms", startX + 2, startY + 4.5);

    let y = startY + 7;
    const baseRowHeight = 6;
    const labelWidth = width * 0.6;
    const valueWidth = width * 0.4;

    // ===== SECTION 1: Sizing DSCR =====
    if (sizingDscrSection && sizingDscrSection.parameters.length > 0) {
        // Section header (merged across columns)
        const sectionHeaderHeight = 6;
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'FD');
        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'S');

        pdf.setTextColor(...colors.textDark);
        pdf.setFontSize(7);
        pdf.setFont("helvetica", "bold");
        const sectionTitle = sizingDscrSection.sectionName;
        const titleWidth = pdf.getTextWidth(sectionTitle);
        pdf.text(sectionTitle, startX + (width - titleWidth) / 2, y + 4);
        y += sectionHeaderHeight;

        // Sizing DSCR data rows (only Term Loan values)
        pdf.setFont("helvetica", "normal");
        sizingDscrSection.parameters.forEach((param) => {
            pdf.setDrawColor(...colors.borderGray);
            pdf.setLineWidth(0.1);

            const paramName = param.parameterName;
            const valueText = param.loanTypes['Term Loan'] || '-';

            // Text wrapping
            const maxLabelWidth = labelWidth - 3;
            const maxValueWidth = valueWidth - 3;

            const labelLines = pdf.splitTextToSize(String(paramName), maxLabelWidth);
            const valueLines = pdf.splitTextToSize(String(valueText), maxValueWidth);

            const maxLines = Math.max(labelLines.length, valueLines.length);
            const rowHeight = Math.max(baseRowHeight, maxLines * 4 + 2);

            // Label cell
            pdf.setFillColor(...colors.tableLabelBg);
            pdf.rect(startX, y, labelWidth, rowHeight, 'FD');

            // Value cell
            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(startX + labelWidth, y, valueWidth, rowHeight, 'FD');

            pdf.setTextColor(...colors.textDark);

            // Render text
            labelLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + 1.5, y + 4 + (lineIndex * 4));
            });

            valueLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + labelWidth + 1.5, y + 4 + (lineIndex * 4));
            });

            y += rowHeight;
        });
    }

    // ===== SECTION 2: Interest Rate =====
    if (interestRateSection && interestRateSection.parameters.length > 0) {
        // Section header (merged across columns)
        const sectionHeaderHeight = 6;
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'FD');
        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'S');

        pdf.setTextColor(...colors.textDark);
        pdf.setFontSize(7);
        pdf.setFont("helvetica", "bold");
        const sectionTitle = interestRateSection.sectionName;
        const titleWidth = pdf.getTextWidth(sectionTitle);
        pdf.text(sectionTitle, startX + (width - titleWidth) / 2, y + 4);
        y += sectionHeaderHeight;

        // Interest Rate data rows (only Term Loan values)
        pdf.setFont("helvetica", "normal");
        interestRateSection.parameters.forEach((param) => {
            pdf.setDrawColor(...colors.borderGray);
            pdf.setLineWidth(0.1);

            const paramName = param.parameterName;
            const valueText = param.loanTypes['Term Loan'] || '-';

            // Text wrapping
            const maxLabelWidth = labelWidth - 3;
            const maxValueWidth = valueWidth - 3;

            const labelLines = pdf.splitTextToSize(String(paramName), maxLabelWidth);
            const valueLines = pdf.splitTextToSize(String(valueText), maxValueWidth);

            const maxLines = Math.max(labelLines.length, valueLines.length);
            const rowHeight = Math.max(baseRowHeight, maxLines * 4 + 2);

            // Label cell
            pdf.setFillColor(...colors.tableLabelBg);
            pdf.rect(startX, y, labelWidth, rowHeight, 'FD');

            // Value cell
            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(startX + labelWidth, y, valueWidth, rowHeight, 'FD');

            pdf.setTextColor(...colors.textDark);

            // Render text
            labelLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + 1.5, y + 4 + (lineIndex * 4));
            });

            valueLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + labelWidth + 1.5, y + 4 + (lineIndex * 4));
            });

            y += rowHeight;
        });
    }

    return y;
};

// ===== TAX EQUITY TABLE =====
export const addTaxEquityTable = (pdf, financeData, startX, startY, width) => {
    const { colors, fonts } = PDF_STYLES;
    const taxEquity = financeData?.taxEquity || {};

    console.log('üíº Adding Tax Equity table');
    console.log('   Tax Equity data:', taxEquity);

    if (Object.keys(taxEquity).length === 0) {
        console.warn('‚ö†Ô∏è No Tax Equity data found, skipping table');
        return startY;
    }

    // Filter to only include types that have data
    const taxEquityTypesWithData = Object.entries(taxEquity).filter(([typeName, parameters]) => {
        return Object.values(parameters).some(val => val && val !== '-');
    });

    if (taxEquityTypesWithData.length === 0) {
        console.warn('‚ö†Ô∏è No Tax Equity data with values found, skipping table');
        return startY;
    }

    const tableStartY = startY;

    // Table header - no border yet
    pdf.setFillColor(...colors.tableHeaderBg);
    pdf.rect(startX, startY, width, 7, 'F');
    pdf.setTextColor(...colors.headerText);
    pdf.setFontSize(8);
    pdf.setFont("helvetica", "bold");
    pdf.text("Tax Equity", startX + 2, startY + 4.5);

    let y = startY + 7;
    const baseRowHeight = 6;
    const labelWidth = width * 0.6;
    const valueWidth = width * 0.4;

    // Loop through each tax equity type that has data
    taxEquityTypesWithData.forEach(([typeName, parameters]) => {
        // Section header (merged across columns) - Tax Equity Type
        const sectionHeaderHeight = 6;
        pdf.setFillColor(...colors.tableLabelBg);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'FD');
        pdf.setDrawColor(...colors.borderGray);
        pdf.rect(startX, y, width, sectionHeaderHeight, 'S');

        pdf.setTextColor(...colors.textDark);
        pdf.setFontSize(7);
        pdf.setFont("helvetica", "bold");
        const titleWidth = pdf.getTextWidth(typeName);
        pdf.text(typeName, startX + (width - titleWidth) / 2, y + 4);
        y += sectionHeaderHeight;

        // Parameters for this tax equity type
        pdf.setFont("helvetica", "normal");
        Object.entries(parameters).forEach(([paramName, value]) => {
            pdf.setDrawColor(...colors.borderGray);
            pdf.setLineWidth(0.1);

            const valueText = value || '-';

            // Format value (add commas for numbers)
            let formattedValue = valueText;
            if (!isNaN(Number(valueText))) {
                // Check if it's a currency/proceeds/basis value
                if (paramName.toLowerCase().includes('$') ||
                    paramName.toLowerCase().includes('proceeds') ||
                    paramName.toLowerCase().includes('basis') ||
                    paramName.toLowerCase().includes('recognized')) {
                    formattedValue = Number(valueText).toLocaleString('en-US');
                } else {
                    formattedValue = valueText; // Keep as is for percentages/rates
                }
            }

            // Text wrapping
            const maxLabelWidth = labelWidth - 3;
            const maxValueWidth = valueWidth - 3;

            const labelLines = pdf.splitTextToSize(String(paramName), maxLabelWidth);
            const valueLines = pdf.splitTextToSize(String(formattedValue), maxValueWidth);

            const maxLines = Math.max(labelLines.length, valueLines.length);
            const rowHeight = Math.max(baseRowHeight, maxLines * 4 + 2);

            // Label cell
            pdf.setFillColor(...colors.tableLabelBg);
            pdf.rect(startX, y, labelWidth, rowHeight, 'FD');

            // Value cell
            pdf.setFillColor(...colors.tableDataBg);
            pdf.rect(startX + labelWidth, y, valueWidth, rowHeight, 'FD');

            pdf.setTextColor(...colors.textDark);

            // Render text
            labelLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + 1.5, y + 4 + (lineIndex * 4));
            });

            valueLines.forEach((line, lineIndex) => {
                pdf.text(line, startX + labelWidth + 1.5, y + 4 + (lineIndex * 4));
            });

      y += rowHeight;
        });
    });
    
    return y;
  };

/**
 * Generates PDF with SVG charts from Recharts
 * @param {string} projectName - Project name
 * @param {string} projectId - Project ID
 */
export const captureAndAddChart = async (pdf, containerId, startX, startY, maxWidth, maxHeight) => {
    const { colors } = PDF_STYLES;

    console.log(` Capturing chart: ${containerId}`);

    const container = document.getElementById(containerId);

    if (!container) {
        console.warn(`‚ö†Ô∏è Container ${containerId} not found`);
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, maxWidth, maxHeight, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('Chart not available', startX + maxWidth / 2, startY + maxHeight / 2, { align: 'center' });
        return startY + maxHeight + 5;
    }

    try {
        // Wait longer for pie charts with complex labels and legends
        const isPieChart = containerId.includes('ownership') || containerId.includes('pie');
        const waitTime = isPieChart ? 1000 : 500; // 1 second for pie charts, 500ms for others
        await new Promise(resolve => setTimeout(resolve, waitTime));
        
        console.log(`Starting capture of ${containerId}...`);
        console.log(`Container dimensions:`, container.offsetWidth, 'x', container.offsetHeight);
        console.log(`Container scroll dimensions:`, container.scrollWidth, 'x', container.scrollHeight);
        
        // Capture the chart as image - use scroll dimensions to capture full content including legends
        const canvas = await html2canvas(container, {
            backgroundColor: '#ffffff',
            scale: 2,
            logging: false, // Disable verbose logging
            useCORS: true,
            allowTaint: false,
            width: container.scrollWidth || container.offsetWidth,
            height: container.scrollHeight || container.offsetHeight,
            windowWidth: container.scrollWidth || container.offsetWidth,
            windowHeight: container.scrollHeight || container.offsetHeight,
        });

        console.log(`üì∏ Canvas created:`, canvas.width, 'x', canvas.height);

        const imageData = canvas.toDataURL('image/png');
        console.log(`‚úÖ Chart ${containerId} captured, data length:`, imageData.length);

        // Force dimensions without maintaining aspect ratio (stretch to fit like in Word)
        const finalWidth = maxWidth;
        const finalHeight = maxHeight;
        const offsetX = 0;  // No centering needed

        // Add image to PDF
        pdf.addImage(imageData, 'PNG', startX + offsetX, startY, finalWidth, finalHeight, undefined, 'FAST');
        console.log(`‚úÖ Chart ${containerId} added to PDF at position (${startX}, ${startY})`);

        return startY + finalHeight + 5;

    } catch (error) {
        console.error(`‚ùå Error capturing ${containerId}:`, error);
        console.error(`Error stack:`, error.stack);
        pdf.setFillColor(255, 240, 240);
        pdf.rect(startX, startY, maxWidth, maxHeight, 'F');
        pdf.setTextColor(200, 50, 50);
        pdf.setFontSize(8);
        pdf.text('Error loading chart', startX + maxWidth / 2, startY + maxHeight / 2, { align: 'center' });
        return startY + maxHeight + 5;
    }
};


// ===== CHART GENERATION FUNCTIONS =====

/**
 * Creates an ownership pie chart (donut chart) using Plotly.js and adds it to PDF
 * @param {jsPDF} pdf - PDF instance
 * @param {Array} ownershipData - Array of {name, value, color}
 * @param {number} startX - X position
 * @param {number} startY - Y position
 * @param {number} width - Chart width in mm
 * @param {number} height - Chart height in mm
 * @returns {number} - Y position after chart
 */
const drawOwnershipPieChart = async (pdf, ownershipData, startX, startY, width, height) => {
    // Dynamically import Plotly to avoid SSR issues
    const Plotly = (await import("plotly.js-dist-min")).default;
    
    if (!ownershipData || ownershipData.length === 0) {
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, width, height, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('No ownership data', startX + width / 2, startY + height / 2, { align: 'center' });
        return startY + height + 5;
    }

    // Convert HSL colors to RGB
    const hslToRgb = (hslStr) => {
        const match = hslStr.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
        if (!match) return 'rgb(108, 182, 255)'; // Default blue
        const h = parseInt(match[1]) / 360;
        const s = parseInt(match[2]) / 100;
        const l = parseInt(match[3]) / 100;
        
        let r, g, b;
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
    };

    // Create div for Plotly
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '-9999px';
    div.style.top = '-9999px';
    div.style.width = (width * 3.779527559) + 'px';
    div.style.height = (height * 3.779527559) + 'px';
    document.body.appendChild(div);

    // Prepare Plotly data with formatted labels for legend
    const data = [{
        type: 'pie',
        labels: ownershipData.map(d => `${d.name}: ${d.value.toFixed(1)}%`), // Include percentage in label
        values: ownershipData.map(d => d.value),
        hole: 0.5, // Donut chart
        marker: {
            colors: ownershipData.map(d => hslToRgb(d.color)),
            line: {
                color: '#ffffff',
                width: 3
            }
        },
        textinfo: 'none', // No text on pie slices - use legend only
        hovertemplate: '<b>%{label}</b><br>%{value:.1f}%<extra></extra>',
        rotation: 90,
        showlegend: true // Show legend for pie chart
    }];

    const layout = {
        width: width * 3.779527559,
        height: height * 3.779527559,
        margin: { l: 20, r: 20, t: 20, b: 80 }, // Reduced right margin, increased bottom for legend
        paper_bgcolor: 'white',
        plot_bgcolor: 'white',
        legend: {
            orientation: 'h', // Horizontal legend below chart
            yanchor: 'top',
            y: -0.15, // Position below the chart
            xanchor: 'center',
            x: 0.5, // Centered
            font: {
                size: 14, // Smaller font (was 18)
                family: 'Arial',
                color: '#374151'
            },
            bgcolor: 'rgba(255, 255, 255, 0.95)',
            bordercolor: '#E5E7EB',
            borderwidth: 2,
            itemclick: false,
            itemdoubleclick: false,
            tracegroupgap: 20 // Spacing between legend items
        }
    };

    const config = {
        displayModeBar: false,
        staticPlot: true
    };

    try {
        // Create Plotly chart
        await Plotly.newPlot(div, data, layout, config);
        
        // Wait for rendering
        await new Promise(resolve => setTimeout(resolve, 200));

        // Get image as base64
        const imgData = await Plotly.toImage(div, {
            format: 'png',
            width: width * 3.779527559,
            height: height * 3.779527559,
            scale: 2
        });

        // Add to PDF
        pdf.addImage(imgData, 'PNG', startX, startY, width, height);
        
        // Clean up
        Plotly.purge(div);
        div.remove();

        return startY + height + 5;
    } catch (error) {
        console.error('Error creating ownership chart:', error);
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, width, height, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('Chart rendering error', startX + width / 2, startY + height / 2, { align: 'center' });
        div.remove();
        return startY + height + 5;
    }
};

/**
 * Creates a generation trend chart (line chart) using Plotly.js and adds it to PDF
 * @param {jsPDF} pdf - PDF instance
 * @param {Array} generationData - Array of {month, planMwh, actualMwh, planPoa, actualPoa}
 * @param {number} startX - X position
 * @param {number} startY - Y position
 * @param {number} width - Chart width in mm
 * @param {number} height - Chart height in mm
 * @returns {number} - Y position after chart
 */
const drawGenerationTrendChart = async (pdf, generationData, startX, startY, width, height) => {
    // Dynamically import Plotly to avoid SSR issues
    const Plotly = (await import("plotly.js-dist-min")).default;
    
    if (!generationData || generationData.length === 0) {
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, width, height, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('No generation data', startX + width / 2, startY + height / 2, { align: 'center' });
        return startY + height + 5;
    }

    // Create div for Plotly
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '-9999px';
    div.style.top = '-9999px';
    div.style.width = (width * 3.779527559) + 'px';
    div.style.height = (height * 3.779527559) + 'px';
    document.body.appendChild(div);

    // Prepare Plotly data - using subplots for dual y-axis
    const months = generationData.map(d => d.month || d.Month || '');
    const planMwh = generationData.map(d => parseFloat(d.planMwh || d.plan_mwh || 0));
    const actualMwh = generationData.map(d => parseFloat(d.actualMwh || d.actual_mwh || 0));
    const planPoa = generationData.map(d => parseFloat(d.planPoa || d.plan_poa || 0));
    const actualPoa = generationData.map(d => parseFloat(d.actualPoa || d.actual_poa || 0));

    const data = [
        {
            type: 'scatter',
            mode: 'lines+markers',
            x: months,
            y: planMwh,
            name: 'Plan MWh',
            line: { 
                color: 'rgba(108, 182, 255, 0.8)',
                width: 2.5,
                dash: 'dash'
            },
            marker: { size: 6, color: 'rgba(108, 182, 255, 0.9)' },
            yaxis: 'y'
        },
        {
            type: 'scatter',
            mode: 'lines+markers',
            x: months,
            y: actualMwh,
            name: 'Actual MWh',
            line: { 
                color: 'rgba(59, 130, 246, 0.9)',
                width: 3
            },
            marker: { size: 8, color: 'rgba(59, 130, 246, 1.0)' },
            yaxis: 'y'
        },
        {
            type: 'scatter',
            mode: 'lines+markers',
            x: months,
            y: planPoa,
            name: 'Plan POA',
            line: { 
                color: 'rgba(34, 197, 94, 0.8)',
                width: 2.5,
                dash: 'dash'
            },
            marker: { size: 6, color: 'rgba(34, 197, 94, 0.9)' },
            yaxis: 'y2'
        },
        {
            type: 'scatter',
            mode: 'lines+markers',
            x: months,
            y: actualPoa,
            name: 'Actual POA',
            line: { 
                color: 'rgba(16, 185, 129, 0.9)',
                width: 3
            },
            marker: { size: 8, color: 'rgba(16, 185, 129, 1.0)' },
            yaxis: 'y2'
        }
    ];

    const layout = {
        width: width * 3.779527559,
        height: height * 3.779527559,
        margin: { l: 60, r: 60, t: 50, b: 60 },
        paper_bgcolor: 'white',
        plot_bgcolor: 'white',
        xaxis: {
            title: {
                text: 'Month',
                font: { size: 14, family: 'Arial' }
            },
            tickfont: { size: 11, family: 'Arial' },
            tickangle: -45,
            gridcolor: 'rgba(0,0,0,0.1)',
            showline: true,
            linecolor: '#D1D5DB',
            linewidth: 1
        },
        yaxis: {
            title: {
                text: 'MWh',
                font: { size: 14, family: 'Arial' }
            },
            tickfont: { size: 11, family: 'Arial' },
            gridcolor: 'rgba(0,0,0,0.1)',
            showline: true,
            linecolor: '#D1D5DB',
            linewidth: 1
        },
        yaxis2: {
            title: {
                text: 'POA (kW/m¬≤)',
                font: { size: 14, family: 'Arial' }
            },
            tickfont: { size: 11, family: 'Arial' },
            overlaying: 'y',
            side: 'right',
            showgrid: false,
            showline: true,
            linecolor: '#D1D5DB',
            linewidth: 1
        },
        legend: {
            orientation: 'h',
            yanchor: 'bottom',
            y: 1.02,
            xanchor: 'right',
            x: 1,
            font: { size: 12, family: 'Arial' }
        },
    };

    const config = {
        displayModeBar: false,
        staticPlot: true
    };

    try {
        // Create Plotly chart
        await Plotly.newPlot(div, data, layout, config);
        
        // Wait for rendering
        await new Promise(resolve => setTimeout(resolve, 200));

        // Get image as base64
        const imgData = await Plotly.toImage(div, {
            format: 'png',
            width: width * 3.779527559,
            height: height * 3.779527559,
            scale: 2
        });

        // Add to PDF
        pdf.addImage(imgData, 'PNG', startX, startY, width, height);
        
        // Clean up
        Plotly.purge(div);
        div.remove();

        return startY + height + 5;
    } catch (error) {
        console.error('Error creating generation trend chart:', error);
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, width, height, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('Chart rendering error', startX + width / 2, startY + height / 2, { align: 'center' });
        div.remove();
        return startY + height + 5;
    }
};

/**
 * Creates a performance horizontal bar chart using Plotly.js and adds it to PDF
 * @param {jsPDF} pdf - PDF instance
 * @param {Array} performanceData - Array of {name, plan, actual}
 * @param {string} title - Chart title
 * @param {number} startX - X position
 * @param {number} startY - Y position
 * @param {number} width - Chart width in mm
 * @param {number} height - Chart height in mm
 * @returns {number} - Y position after chart
 */

const drawPerformanceBarChart = async (pdf, performanceData, title, startX, startY, width, height) => {
    // Dynamically import Plotly to avoid SSR issues
    const Plotly = (await import("plotly.js-dist-min")).default;
    
    if (!performanceData || performanceData.length === 0) {
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, width, height, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('No performance data', startX + width / 2, startY + height / 2, { align: 'center' });
        return startY + height + 5;
    }

    // Filter to only Revenue, EBITDA, OPEX
    const metricOrder = ['Revenue', 'EBITDA', 'OPEX', 'Operating Expenses'];
    let filteredData = performanceData.filter(item => {
        const name = item.name || '';
        return metricOrder.some(metric => name.toLowerCase().includes(metric.toLowerCase()));
    });

    if (filteredData.length === 0) {
        filteredData = performanceData;
    }

    // Sort: Revenue, EBITDA, OPEX
    filteredData.sort((a, b) => {
        const aName = (a.name || '').toLowerCase();
        const bName = (b.name || '').toLowerCase();
        const aIdx = metricOrder.findIndex(m => aName.includes(m.toLowerCase()));
        const bIdx = metricOrder.findIndex(m => bName.includes(m.toLowerCase()));
        return (aIdx === -1 ? 99 : aIdx) - (bIdx === -1 ? 99 : bIdx);
    });

    // Reverse for horizontal bars (top to bottom: Revenue, EBITDA, OPEX)
    filteredData.reverse();

    // Create div for Plotly
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '-9999px';
    div.style.top = '-9999px';
    div.style.width = (width * 3.779527559) + 'px';
    div.style.height = (height * 3.779527559) + 'px';
    document.body.appendChild(div);

    // Prepare Plotly data - matching frontend Recharts styling
    const labels = filteredData.map(d => d.name || '');
    const planValues = filteredData.map(d => parseFloat(d.plan || 0));
    const actualValues = filteredData.map(d => parseFloat(d.actual || 0));

    // Calculate max value and set x-axis range to make bars appear longer
    const allValues = [...planValues, ...actualValues].filter(v => !isNaN(v) && v > 0);
    const maxValue = allValues.length > 0 ? Math.max(...allValues) : 1000;
    const xAxisMax = maxValue * 1.15; // Add 15% padding above max value

    // Helper function to format numbers without $ sign (like frontend formatNumber)
    const formatNumber = (value) => {
        if (value === null || value === undefined || value === 0) return '';
        return value.toLocaleString('en-US');
    };

    const data = [
        {
            type: 'bar',
            orientation: 'h',
            y: labels,
            x: planValues,
            name: 'Plan',
            marker: { 
                color: 'hsl(212, 95%, 68%)', // Frontend plan color
                line: { color: 'hsl(212, 95%, 68%)', width: 0 }, // No border
                cornerradius: 4 // Rounded corners (4px radius)
            },
            text: planValues.map(v => v > 0 ? formatNumber(v) : ''), // Numbers without $ sign, only show if > 0
            textposition: 'inside', // Labels inside bars
            textfont: { size: 14, family: 'Arial', color: '#FFFFFF' }, // Increased white text size for visibility (was 12)
            width: 0.35, // Thinner bars for better appearance
            textangle: 0, // Keep text horizontal
            insidetextanchor: 'end' // Align text to the right side inside the bar (away from white border)
        },
        {
            type: 'bar',
            orientation: 'h',
            y: labels,
            x: actualValues,
            name: 'Actual',
            marker: { 
                color: 'hsl(177, 100%, 35%)', // Frontend actual color
                line: { color: 'hsl(177, 100%, 35%)', width: 0 }, // No border
                cornerradius: 4 // Rounded corners (4px radius)
            },
            text: actualValues.map(v => v > 0 ? formatNumber(v) : ''), // Numbers without $ sign, only show if > 0
            textposition: 'inside', // Labels inside bars
            textfont: { size: 14, family: 'Arial', color: '#FFFFFF' }, // Increased white text size for visibility (was 12)
            width: 0.35, // Thinner bars for better appearance
            textangle: 0, // Keep text horizontal
            insidetextanchor: 'end' // Align text to the right side inside the bar (away from white border)
        }
    ];

    const layout = {
        width: width * 3.779527559, // No extra width needed since values are inside bars
        height: height * 3.779527559,
        title: {
            text: `<b>${title}</b>`,
            font: { size: 18, family: 'Arial' }, // Increased font size for better visibility
            x: 0,
            xanchor: 'left', // Left-aligned title
            y: 0.98 // Position title near top
        },
        margin: { l: 80, r: 80, t: 30, b: 60 }, // Further reduced top margin to decrease space between headings and graphs
        paper_bgcolor: 'white',
        plot_bgcolor: 'white',
        xaxis: {
            title: {
                text: 'Amount ($)',
                font: { size: 12, family: 'Arial' }, // Reduced from 14
                standoff: 0
            },
            tickfont: { size: 10, family: 'Arial' }, // Reduced from 12
            tickformat: '.1s', // SI notation: shows "M" for millions (e.g., 1.5M instead of 1,500,000)
            tickangle: 0, // Keep x-axis labels horizontal (not diagonal)
            gridcolor: 'rgba(0,0,0,0.1)',
            showgrid: true,
            showline: true, // Show x-axis line
            linecolor: 'rgba(200, 200, 200, 0.8)', // Light grey axis line
            linewidth: 1,
            zeroline: false,
            range: [0, xAxisMax] // Set explicit range to make bars appear longer
        },
        yaxis: {
            type: 'category',
            tickfont: { size: 10, family: 'Arial' }, // Reduced from 12
            showgrid: false, // No horizontal grid (frontend has horizontal={false})
            showline: true, // Show y-axis line
            linecolor: 'rgba(200, 200, 200, 0.8)', // Light grey axis line
            linewidth: 1,
            zeroline: false
        },
        showlegend: false, // Hide individual legends - using shared legend between headings
        barmode: 'group',
        bargroupgap: 0.2 // Gap between plan and actual bars
    };

    const config = {
        displayModeBar: false,
        staticPlot: true
    };

    try {
        // Create Plotly chart
        await Plotly.newPlot(div, data, layout, config);
        
        // Wait for rendering
        await new Promise(resolve => setTimeout(resolve, 200));

        // Get image as base64 - no extra width needed since values are inside bars
        const imgData = await Plotly.toImage(div, {
            format: 'png',
            width: width * 3.779527559,
            height: height * 3.779527559,
            scale: 2
        });

        // Add to PDF - use standard width since values are inside bars
        pdf.addImage(imgData, 'PNG', startX, startY, width, height);
        
        // Clean up
        Plotly.purge(div);
        div.remove();

        return startY + height + 5;
    } catch (error) {
        console.error('Error creating performance chart:', error);
        pdf.setFillColor(240, 240, 240);
        pdf.rect(startX, startY, width, height, 'F');
        pdf.setTextColor(150, 150, 150);
        pdf.setFontSize(10);
        pdf.text('Chart rendering error', startX + width / 2, startY + height / 2, { align: 'center' });
        div.remove();
        return startY + height + 5;
    }
};

// Update generateTestPDF:
export const generateTestPDF = async (projectName, projectId, projectData, financeData, performanceData) => {
    console.log('üöÄ Starting PDF generation...');
    
    // Wait for UI to settle after button click and state changes
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    console.log('üìÑ PDF document initialized');


    // ===== PAGE 1: Overview =====
    addHeader(pdf, projectName);

    let y = PDF_STYLES.margins.header;

    // LEFT COLUMN: Description + Milestones
    const leftColumnX = 10;
    const leftColumnWidth = 50;

    let leftY = addProjectDescription(pdf, projectData, y);
    leftY = addMilestoneTimeline(pdf, projectData, leftY);
    leftY = addUpcomingEventsTable(pdf, projectData, leftY);

    // RIGHT SIDE: Project Details Table
    const tableX = leftColumnX + leftColumnWidth + 20;
    const tableWidth = 120; // Reduced width to prevent cutoff (leave 10mm right margin)

    const tablesY = y;

    // Add "Project Details" heading
    pdf.setFontSize(PDF_STYLES.fonts.sectionTitle);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(...PDF_STYLES.colors.headerBg);
    pdf.text("Project Details", tableX, tablesY);

    const projectDetailsY = tablesY + 3;

    const table1EndY = addProjectLocationTable(pdf, projectData, tableX, projectDetailsY, tableWidth);

    // Add Associated Parties table below Project Location table
    const associatedPartiesY = table1EndY + 5;
    const table2EndY = addAssociatedPartiesTable(pdf, projectData, financeData, tableX, associatedPartiesY, tableWidth);

    // ===== PERFORMANCE SECTION (ALIGNED WITH PROJECT DETAILS ON RIGHT) =====
    const perfY = table2EndY+10;
    const { colors, fonts } = PDF_STYLES;
    pdf.setFontSize(fonts.sectionTitle);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(...colors.headerBg);
    pdf.text("Performance", tableX, perfY);

    let perfSectionY = perfY + 1; // Minimal spacing from heading to DSCR table

    // Add DSCR table first (same width as location table, no heading)
    const dscrEndY = addDscrTable(pdf, financeData, tableX, perfSectionY, tableWidth);
    perfSectionY = dscrEndY + 5; // Increased spacing between DSCR table and charts

    // Performance charts side by side - with plenty of space for values
    const perfChartWidth = 100; // Chart width
    const perfChartHeight = 58; // Slightly increased height (was 55)
    const perfCol1X = 5; // Left chart position
    const perfCol2X = 112; // Right chart position (5 + 100 + 7mm gap - increased spacing)

    // Prepare performance data - matching frontend logic
    const monthlyPerformanceData = (() => {
        if (!performanceData?.monthly) return [];
        const monthKeys = Object.keys(performanceData.monthly);
        if (monthKeys.length === 0) return [];
        const latestMonth = monthKeys[monthKeys.length - 1];
        return performanceData.monthly[latestMonth] || [];
    })();

    const ytdPerformanceData = (() => {
        if (!performanceData?.ytd) return [];
        const ytdKeys = Object.keys(performanceData.ytd);
        if (ytdKeys.length === 0) return [];
        const latestYtd = ytdKeys[ytdKeys.length - 1];
        return performanceData.ytd[latestYtd] || [];
    })();

    const latestMonthName = (() => {
        if (!performanceData?.monthly) return 'Monthly';
        const monthKeys = Object.keys(performanceData.monthly);
        return monthKeys.length > 0 ? monthKeys[monthKeys.length - 1] : 'Monthly';
    })();

    const latestYtdName = (() => {
        if (!performanceData?.ytd) return 'YTD';
        const ytdKeys = Object.keys(performanceData.ytd);
        return ytdKeys.length > 0 ? ytdKeys[ytdKeys.length - 1] : 'YTD';
    })();

    // Format month name to "YTD (Aug'25)" format
    const formatMonthToYtd = (monthName) => {
        if (!monthName || monthName === 'Monthly') return 'YTD';
        
        // Parse month and year from format like "August 2025"
        const parts = monthName.split(' ');
        if (parts.length < 2) return `YTD (${monthName})`;
        
        const month = parts[0];
        const year = parts[1];
        
        // Convert month name to abbreviation
        const monthAbbr = {
            'January': 'Jan', 'February': 'Feb', 'March': 'Mar', 'April': 'Apr',
            'May': 'May', 'June': 'Jun', 'July': 'Jul', 'August': 'Aug',
            'September': 'Sep', 'October': 'Oct', 'November': 'Nov', 'December': 'Dec'
        };
        
        const monthShort = monthAbbr[month] || month.substring(0, 3);
        const yearShort = year.length === 4 ? year.substring(2) : year;
        
        return `YTD (${monthShort}'${yearShort})`;
    };

    // Draw performance charts with plenty of space
    await drawPerformanceBarChart(pdf, monthlyPerformanceData, latestMonthName, perfCol1X, perfSectionY, perfChartWidth, perfChartHeight);
    await drawPerformanceBarChart(pdf, ytdPerformanceData, formatMonthToYtd(latestMonthName), perfCol2X, perfSectionY, perfChartWidth, perfChartHeight);

    // Draw single legend centered below both charts
    const legendY = perfSectionY + perfChartHeight - 9; // Position below chart images
    
    pdf.setFontSize(9); // Reduced font size
    pdf.setFont("helvetica", "normal");
    
    // Calculate center position between both charts
    const chartCenterX = (perfCol1X + perfCol2X + perfChartWidth) / 2;
    
    // Get text widths to center the legend properly
    const planTextWidth = pdf.getTextWidth('Plan');
    const actualTextWidth = pdf.getTextWidth('Actual');
    const totalTextWidth = planTextWidth + actualTextWidth + 2; // 2mm spacing between labels
    
    // Start position to center both labels
    const legendStartX = chartCenterX - (totalTextWidth / 2);
    
    // Plan text in blue color
    pdf.setTextColor(108, 182, 255); // hsl(212, 95%, 68%) in RGB - blue color
    pdf.text('Plan', legendStartX, legendY);
    
    // Actual text in green color (minimal spacing)
    pdf.setTextColor(0, 168, 89); // hsl(177, 100%, 35%) in RGB - green color
    pdf.text('Actual', legendStartX + planTextWidth + 2, legendY); // Minimal 2mm spacing between Plan and Actual

    // Update perfSectionY to include chart height and legend below
    perfSectionY = legendY + 5; // Position after legend with spacing

    // Update Y position to max of left column or right column
    y = Math.max(leftY, perfSectionY) + 10;

    // Check if we need a new page
    if (y > 220) {
        pdf.addPage();
        addHeader(pdf, projectName);
        y = PDF_STYLES.margins.header;
    }

    // ===== GENERATION TREND (FULL WIDTH BELOW) =====
    const genTrendX = 10;
    const genTrendWidth = 170; // Full page width minus margins
    const genTrendHeight = 75; // Increased height (was 65)

    pdf.setFontSize(fonts.sectionTitle);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(...colors.headerBg);
    pdf.text(`Generation Trend - ${formatMonthToYtd(latestMonthName)}`, genTrendX, y);
    y += 5;

    // Prepare generation trend data
    const generationTrendData = performanceData?.generationTrend || [];
    const genTrendEndY = await drawGenerationTrendChart(pdf, generationTrendData, genTrendX, y, genTrendWidth, genTrendHeight);
    y = genTrendEndY + 10;

    // Add Commercial section title (aligned with Generation Trend)
    pdf.setFontSize(fonts.sectionTitle);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(...colors.headerBg);
    pdf.text("Commercial", genTrendX, y);
    y += 3;

    // Layout: Two tables side by side
    const commercialTable1X = 10;  // Left table X position
    const commercialTable2X = 110; // Right table X position (shifted right)
    const commercialTableWidth = 90; // Each table width

    const commercialStartY = y;

    // O&M Details table (left side)
    const omDetailsEndY = addOMDetailsTable(pdf, projectData, commercialTable1X, commercialStartY, commercialTableWidth);

    // Offtake table (right side, same Y position)
    const offtakeEndY = addOfftakeTable(pdf, projectData, commercialTable2X, commercialStartY, commercialTableWidth);

    // Update Y to the bottom of whichever table is taller
    y = Math.max(omDetailsEndY, offtakeEndY) + 10;

    // Check if we need a new page for Financing section
    if (y > 220) {
        pdf.addPage();
        addHeader(pdf, projectName);
        y = PDF_STYLES.margins.header;
    }

    // ===== FINANCING SECTION (CONTINUES BELOW COMMERCIAL) =====
    // Add Financing section title (aligned with other sections)
    pdf.setFontSize(fonts.sectionTitle);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(...colors.headerBg);
    pdf.text("Financing", 10, y);
    y += 3;

    // Layout: Ownership pie chart (left) + Debt vs Swaps table (right, full width)
    const ownershipChartX = 10;  // Aligned with interconnect table (x=10)
    const ownershipChartWidth = 90;  // Pie chart width (ends at 105mm)
    const ownershipChartHeight = 85;  // Increased height to make chart bigger (was 70)

    const debtSwapsTableX = 110;  // Aligned with offtake details table (x=110)
    const debtSwapsTableWidth = 90;  // Same width as offtake details table

    const financingStartY = y;

    // Prepare ownership data
    const ownershipData = (() => {
        let nonDesriOwnership = 0;
        if (financeData?.assetCo && financeData.assetCo.length > 0) {
            const totalNonDesri = financeData.assetCo.reduce((sum, asset) => {
                return sum + (asset.ownership || 0);
            }, 0);
            nonDesriOwnership = totalNonDesri;
        }
        const desriOwnership = 100 - nonDesriOwnership;
        return [
            {
                name: "DESRI Ownership",
                value: parseFloat(desriOwnership.toFixed(1)),
                color: "hsl(177, 100%, 31%)"
            },
            {
                name: "Non-DESRI Ownership",
                value: parseFloat(nonDesriOwnership.toFixed(1)),
                color: "hsl(212, 95%, 68%)"
            }
        ];
    })();

    // Ownership pie chart (left side) - draw using Chart.js
    await drawOwnershipPieChart(pdf, ownershipData, ownershipChartX, financingStartY, ownershipChartWidth, ownershipChartHeight);

    // Debt vs Swaps table (right side, takes remaining width)
    console.log('üìä About to add Debt vs Swaps table');
    console.log('   financeData:', financeData);
    console.log('   debtVsSwaps:', financeData?.debtVsSwaps);
    const debtTableEndY = addDebtVsSwapsTable(pdf, financeData, debtSwapsTableX, financingStartY, debtSwapsTableWidth);
    console.log('‚úÖ Debt vs Swaps table added, endY:', debtTableEndY);

    // Update Y position for next row of tables
    y = Math.max(ownershipChartHeight + financingStartY, debtTableEndY) + 10;

    // ===== THREE TABLES IN A ROW: Corporate Financing, Key Financing Terms, Tax Equity =====
    // Add new page to prevent tables from being cut off
    pdf.addPage();
    addHeader(pdf, projectName);
    y = PDF_STYLES.margins.header;
    const financingTable1X = 10;
    const financingTable2X = 75;
    const financingTable3X = 140;
    const financingTableWidth = 60;

    const threeTablesStartY = y;

    // Corporate Financing (left)
    const corpFinEndY = addCorporateFinancingTable(pdf, financeData, financingTable1X, threeTablesStartY, financingTableWidth);

    // Key Financing Terms (center)
    const keyTermsEndY = addKeyFinancingTermsTable(pdf, financeData, financingTable2X, threeTablesStartY, financingTableWidth);

    // Tax Equity (right)
    const taxEquityEndY = addTaxEquityTable(pdf, financeData, financingTable3X, threeTablesStartY, financingTableWidth);

    y = Math.max(corpFinEndY, keyTermsEndY, taxEquityEndY);

    // Add footers
    const totalPages = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        addFooter(pdf, i, totalPages);
    }

    console.log('üíæ Saving PDF...');
    // Sanitize project name for filename: replace spaces with underscores, remove special characters
    const sanitizedProjectName = projectName
      .replace(/\s+/g, '_')  // Replace spaces with underscores
      .replace(/[^a-zA-Z0-9_-]/g, '')  // Remove special characters except underscores and hyphens
      .trim();
    const fileName = `${sanitizedProjectName}_Report.pdf`;
    pdf.save(fileName);
    console.log('‚úÖ PDF downloaded successfully!');
};